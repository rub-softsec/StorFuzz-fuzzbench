diff --git a/fuzzers/ddfuzz/Cargo.toml b/fuzzers/ddfuzz/Cargo.toml
new file mode 100644
index 00000000..fa34fa4a
--- /dev/null
+++ b/fuzzers/ddfuzz/Cargo.toml
@@ -0,0 +1,39 @@
+[package]
+name = "ddfuzz"
+version = "0.13.0"
+authors = ["", "Andrea Fioraldi <andreafioraldi@gmail.com>", "Dominik Maier <domenukk@gmail.com>"]
+edition = "2021"
+
+[features]
+default = ["std"]
+std = []
+no_link_main = ["libafl_targets/libfuzzer_no_link_main"]
+
+[profile.release]
+lto = true
+codegen-units = 1
+opt-level = 3
+debug = true
+
+[profile.release-fuzzbench]
+inherits = "release"
+debug = false
+strip = true
+
+[build-dependencies]
+cc = { version = "1.0", features = ["parallel"] }
+which = "6.0"
+
+[dependencies]
+libafl = { path = "../../libafl/" }
+libafl_bolts = { path = "../../libafl_bolts/" }
+libafl_targets = { path = "../../libafl_targets/", features = ["sancov_pcguard_hitcounts", "libfuzzer"] }
+# TODO Include it only when building cc
+libafl_cc = { path = "../../libafl_cc/" }
+clap = { version = "4.0", features = ["default"] }
+nix = { version = "0.29", features = ["fs"] }
+mimalloc = { version = "*", default-features = false }
+
+[lib]
+name = "ddfuzz"
+crate-type = ["staticlib"]
diff --git a/fuzzers/ddfuzz/src/bin/libafl_cc.rs b/fuzzers/ddfuzz/src/bin/libafl_cc.rs
new file mode 100644
index 00000000..e2f1c339
--- /dev/null
+++ b/fuzzers/ddfuzz/src/bin/libafl_cc.rs
@@ -0,0 +1,45 @@
+use std::env;
+
+use libafl_cc::{ClangWrapper, CompilerWrapper, LLVMPasses, ToolWrapper};
+
+pub fn main() {
+    let mut args: Vec<String> = env::args().collect();
+    if args.len() > 1 {
+        let mut dir = env::current_exe().unwrap();
+        let wrapper_name = dir.file_name().unwrap().to_str().unwrap();
+
+        let is_cpp = match wrapper_name[wrapper_name.len()-2..].to_lowercase().as_str() {
+            "cc" => false,
+            "++" | "pp" | "xx" => true,
+            _ => panic!("Could not figure out if c or c++ wrapper was called. Expected {dir:?} to end with c or cxx"),
+        };
+
+        dir.pop();
+
+        // Must be always present, even without --libafl
+        args.push("-fsanitize-coverage=trace-pc-guard".into());
+
+        let mut cc = ClangWrapper::new();
+
+        #[cfg(any(target_os = "linux", target_vendor = "apple"))]
+        cc.add_pass(LLVMPasses::AutoTokens);
+
+        if let Some(code) = cc
+            .cpp(is_cpp)
+            // silence the compiler wrapper output, needed for some configure scripts.
+            .silence(true)
+            // add arguments only if --libafl or --libafl-no-link are present
+            .need_libafl_arg(true)
+            .parse_args(&args)
+            .expect("Failed to parse the command line")
+            .link_staticlib(&dir, "ddfuzz")
+            .add_pass(LLVMPasses::DDG)
+            .run()
+            .expect("Failed to run the wrapped compiler")
+        {
+            std::process::exit(code);
+        }
+    } else {
+        panic!("LibAFL CC: No Arguments given");
+    }
+}
diff --git a/fuzzers/ddfuzz/src/bin/libafl_cxx.rs b/fuzzers/ddfuzz/src/bin/libafl_cxx.rs
new file mode 100644
index 00000000..dabd2297
--- /dev/null
+++ b/fuzzers/ddfuzz/src/bin/libafl_cxx.rs
@@ -0,0 +1,5 @@
+pub mod libafl_cc;
+
+fn main() {
+    libafl_cc::main();
+}
diff --git a/fuzzers/ddfuzz/src/lib.rs b/fuzzers/ddfuzz/src/lib.rs
new file mode 100644
index 00000000..c2519070
--- /dev/null
+++ b/fuzzers/ddfuzz/src/lib.rs
@@ -0,0 +1,393 @@
+//! A singlethreaded libfuzzer-like fuzzer that can auto-restart.
+use mimalloc::MiMalloc;
+#[global_allocator]
+static GLOBAL: MiMalloc = MiMalloc;
+
+use core::{cell::RefCell, time::Duration};
+#[cfg(unix)]
+use std::os::unix::io::{AsRawFd, FromRawFd};
+use std::{
+    env,
+    fs::{self, File, OpenOptions},
+    io::{self, Read, Write},
+    path::PathBuf,
+    process,
+};
+
+use clap::{Arg, Command};
+use libafl::{
+    corpus::{Corpus, InMemoryOnDiskCorpus, OnDiskCorpus},
+    events::SimpleRestartingEventManager,
+    executors::{inprocess::InProcessExecutor, ExitKind},
+    feedback_or,
+    feedbacks::{CrashFeedback, MaxMapFeedback, TimeFeedback},
+    fuzzer::{Fuzzer, StdFuzzer},
+    inputs::{BytesInput, HasTargetBytes},
+    monitors::{SimpleMonitor, OnDiskTOMLMonitor},
+    mutators::{
+        scheduled::havoc_mutations, tokens_mutations,
+        StdMOptMutator, Tokens,
+    },
+    observers::{CanTrack, HitcountsMapObserver, TimeObserver},
+    schedulers::{
+        powersched::PowerSchedule, IndexesLenTimeMinimizerScheduler, StdWeightedScheduler,
+    },
+    stages::{
+        calibrate::CalibrationStage, power::StdPowerMutationalStage,
+    },
+    state::{HasCorpus, StdState},
+    Error, HasMetadata,
+};
+use libafl_bolts::{
+    current_time,
+    os::dup2,
+    rands::StdRand,
+    shmem::{ShMemProvider, StdShMemProvider},
+    tuples::{tuple_list, Merge},
+    AsSlice,
+};
+#[cfg(any(target_os = "linux", target_vendor = "apple"))]
+use libafl_targets::autotokens;
+use libafl_targets::{
+    libfuzzer_initialize, libfuzzer_test_one_input, std_edges_map_observer, std_ddg_map_observer
+};
+#[cfg(unix)]
+use nix::unistd::dup;
+use libafl::feedbacks::AflMapFeedback;
+
+/// The fuzzer main (as `no_mangle` C function)
+#[no_mangle]
+pub extern "C" fn libafl_main() {
+    // Registry the metadata types used in this fuzzer
+    // Needed only on no_std
+    // unsafe { RegistryBuilder::register::<Tokens>(); }
+
+    let res = match Command::new(env!("CARGO_PKG_NAME"))
+        .version(env!("CARGO_PKG_VERSION"))
+        .author("AFLplusplus team")
+        .about("LibAFL-based DDFuzz")
+        .arg(
+            Arg::new("out")
+                .short('o')
+                .long("output")
+                .help("The directory to place finds in ('corpus')"),
+        )
+        .arg(
+            Arg::new("in")
+                .short('i')
+                .long("input")
+                .help("The directory to read initial inputs from ('seeds')"),
+        )
+        .arg(
+            Arg::new("tokens")
+                .short('x')
+                .long("tokens")
+                .help("A file to read tokens from, to be used during fuzzing"),
+        )
+        .arg(
+            Arg::new("logfile")
+                .short('l')
+                .long("logfile")
+                .help("Duplicates all output to this file")
+                .default_value("libafl.log"),
+        )
+        .arg(
+            Arg::new("timeout")
+                .short('t')
+                .long("timeout")
+                .help("Timeout for each individual execution, in milliseconds")
+                .default_value("1200"),
+        )
+        .arg(Arg::new("remaining"))
+        .try_get_matches()
+    {
+        Ok(res) => res,
+        Err(err) => {
+            println!(
+                "Syntax: {}, [-x dictionary] -o corpus_dir -i seed_dir\n{:?}",
+                env::current_exe()
+                    .unwrap_or_else(|_| "fuzzer".into())
+                    .to_string_lossy(),
+                err,
+            );
+            return;
+        }
+    };
+
+    println!(
+        "Workdir: {:?}",
+        env::current_dir().unwrap().to_string_lossy().to_string()
+    );
+
+    if let Some(filenames) = res.get_many::<String>("remaining") {
+        let filenames: Vec<&str> = filenames.map(String::as_str).collect();
+        if !filenames.is_empty() {
+            run_testcases(&filenames);
+            return;
+        }
+    }
+
+    // For fuzzbench, crashes and finds are inside the same `corpus` directory, in the "queue" and "crashes" subdir.
+    let mut out_dir = PathBuf::from(
+        res.get_one::<String>("out")
+            .expect("The --output parameter is missing")
+            .to_string(),
+    );
+    if fs::create_dir(&out_dir).is_err() {
+        println!("Out dir at {:?} already exists.", &out_dir);
+        if !out_dir.is_dir() {
+            println!("Out dir at {:?} is not a valid directory!", &out_dir);
+            return;
+        }
+    }
+
+    let stats_file = out_dir.clone().join("stats.toml");
+
+    let mut crashes = out_dir.clone();
+    crashes.push("crashes");
+    out_dir.push("queue");
+
+    let in_dir = PathBuf::from(
+        res.get_one::<String>("in")
+            .expect("The --input parameter is missing")
+            .to_string(),
+    );
+    if !in_dir.is_dir() {
+        println!("In dir at {:?} is not a valid directory!", &in_dir);
+        return;
+    }
+
+    let tokens = res.get_one::<String>("tokens").map(PathBuf::from);
+
+    let logfile = PathBuf::from(res.get_one::<String>("logfile").unwrap().to_string());
+
+    let timeout = Duration::from_millis(
+        res.get_one::<String>("timeout")
+            .unwrap()
+            .to_string()
+            .parse()
+            .expect("Could not parse timeout in milliseconds"),
+    );
+
+    fuzz(out_dir, crashes, &in_dir, tokens, &logfile, timeout, &stats_file)
+        .expect("An error occurred while fuzzing");
+}
+
+fn run_testcases(filenames: &[&str]) {
+    // The actual target run starts here.
+    // Call LLVMFUzzerInitialize() if present.
+    let args: Vec<String> = env::args().collect();
+    if libfuzzer_initialize(&args) == -1 {
+        println!("Warning: LLVMFuzzerInitialize failed with -1");
+    }
+
+    println!(
+        "You are not fuzzing, just executing {} testcases",
+        filenames.len()
+    );
+    for fname in filenames {
+        println!("Executing {fname}");
+
+        let mut file = File::open(fname).expect("No file found");
+        let mut buffer = vec![];
+        file.read_to_end(&mut buffer).expect("Buffer overflow");
+
+        libfuzzer_test_one_input(&buffer);
+    }
+}
+
+/// The actual fuzzer
+#[allow(clippy::too_many_lines)]
+fn fuzz(
+    corpus_dir: PathBuf,
+    objective_dir: PathBuf,
+    seed_dir: &PathBuf,
+    tokenfile: Option<PathBuf>,
+    logfile: &PathBuf,
+    timeout: Duration,
+    stats_file: &PathBuf,
+) -> Result<(), Error> {
+    let log = RefCell::new(OpenOptions::new().append(true).create(true).open(logfile)?);
+
+    #[cfg(unix)]
+    let mut stdout_cpy = unsafe {
+        let new_fd = dup(io::stdout().as_raw_fd())?;
+        File::from_raw_fd(new_fd)
+    };
+    #[cfg(unix)]
+    let file_null = File::open("/dev/null")?;
+
+    // 'While the monitor are state, they are usually used in the broker - which is likely never restarted
+    let monitor = OnDiskTOMLMonitor::new(
+        stats_file,
+        SimpleMonitor::with_user_monitor(
+            |s| {
+                #[cfg(unix)]
+                writeln!(&mut stdout_cpy, "{s}").unwrap();
+                #[cfg(windows)]
+                println!("{s}");
+                writeln!(log.borrow_mut(), "{:?} {s}", current_time()).unwrap();
+            }
+        )
+    );
+
+    // We need a shared map to store our state before a crash.
+    // This way, we are able to continue fuzzing afterwards.
+    let mut shmem_provider = StdShMemProvider::new()?;
+
+    let (state, mut mgr) = match SimpleRestartingEventManager::launch(monitor, &mut shmem_provider)
+    {
+        // The restarting state will spawn the same process again as child, then restarted it each time it crashes.
+        Ok(res) => res,
+        Err(err) => match err {
+            Error::ShuttingDown => {
+                return Ok(());
+            }
+            _ => {
+                panic!("Failed to setup the restarter: {err}");
+            }
+        },
+    };
+
+    // Create an observation channel using the coverage map
+    // We don't use the hitcounts (see the Cargo.toml, we use pcguard_edges)
+    let edges_observer =
+        HitcountsMapObserver::new(unsafe { std_edges_map_observer("edges") }).track_indices();
+
+    let ddg_observer =
+        HitcountsMapObserver::new(unsafe { std_ddg_map_observer("ddg") }).track_indices();
+
+    // Create an observation channel to keep track of the execution time
+    let time_observer = TimeObserver::new("time");
+
+    let map_feedback = MaxMapFeedback::new(&edges_observer);
+
+    let ddg_feedback = AflMapFeedback::new(&ddg_observer);
+
+    let calibration = CalibrationStage::new(&map_feedback);
+
+    // Feedback to rate the interestingness of an input
+    // This one is composed by two Feedbacks in OR
+    let mut feedback = feedback_or!(
+        // New maximization map feedback linked to the edges observer and the feedback state
+        map_feedback,
+        ddg_feedback,
+        // Time feedback, this one does not need a feedback state
+        TimeFeedback::new(&time_observer)
+    );
+
+    // A feedback to choose if an input is a solution or not
+    let mut objective = CrashFeedback::new();
+
+    // If not restarting, create a State from scratch
+    let mut state = state.unwrap_or_else(|| {
+        StdState::new(
+            // RNG
+            StdRand::new(),
+            // Corpus that will be evolved, we keep it in memory for performance
+            InMemoryOnDiskCorpus::new(corpus_dir).unwrap(),
+            // Corpus in which we store solutions (crashes in this example),
+            // on disk so the user can get them after stopping the fuzzer
+            OnDiskCorpus::new(objective_dir).unwrap(),
+            // States of the feedbacks.
+            // The feedbacks can report the data that should persist in the State.
+            &mut feedback,
+            // Same for objective feedbacks
+            &mut objective,
+        )
+        .unwrap()
+    });
+
+    println!("Let's fuzz :)");
+
+    // The actual target run starts here.
+    // Call LLVMFUzzerInitialize() if present.
+    let args: Vec<String> = env::args().collect();
+    if libfuzzer_initialize(&args) == -1 {
+        println!("Warning: LLVMFuzzerInitialize failed with -1");
+    }
+
+    // Setup a MOPT mutator
+    let mutator = StdMOptMutator::new(
+        &mut state,
+        havoc_mutations().merge(tokens_mutations()),
+        7,
+        5,
+    )?;
+
+    let power = StdPowerMutationalStage::new(mutator);
+
+    // A minimization+queue policy to get testcasess from the corpus
+    let scheduler = IndexesLenTimeMinimizerScheduler::new(
+        &edges_observer,
+        StdWeightedScheduler::with_schedule(&mut state, &edges_observer, Some(PowerSchedule::FAST)),
+    );
+
+    // A fuzzer with feedbacks and a corpus scheduler
+    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);
+
+    // The wrapped harness function, calling out to the LLVM-style harness
+    let mut harness = |input: &BytesInput| {
+        let target = input.target_bytes();
+        let buf = target.as_slice();
+        libfuzzer_test_one_input(buf);
+        ExitKind::Ok
+    };
+
+    // Create the executor for an in-process function with one observer for edge coverage and one for the execution time
+    let mut executor = InProcessExecutor::with_timeout(
+        &mut harness,
+        tuple_list!(edges_observer, ddg_observer, time_observer),
+        &mut fuzzer,
+        &mut state,
+        &mut mgr,
+        timeout,
+    )?;
+
+    // The order of the stages matter!
+    let mut stages = tuple_list!(calibration, power);
+
+    // Read tokens
+    if state.metadata_map().get::<Tokens>().is_none() {
+        let mut toks = Tokens::default();
+        if let Some(tokenfile) = tokenfile {
+            toks.add_from_file(tokenfile)?;
+        }
+        #[cfg(any(target_os = "linux", target_vendor = "apple"))]
+        {
+            toks += autotokens()?;
+        }
+
+        if !toks.is_empty() {
+            state.add_metadata(toks);
+        }
+    }
+
+    // In case the corpus is empty (on first run), reset
+    if state.must_load_initial_inputs() {
+        state
+            .load_initial_inputs(&mut fuzzer, &mut executor, &mut mgr, &[seed_dir.clone()])
+            .unwrap_or_else(|_| {
+                println!("Failed to load initial corpus at {:?}", &seed_dir);
+                process::exit(0);
+            });
+        println!("We imported {} inputs from disk.", state.corpus().count());
+    }
+
+    // Remove target output (logs still survive)
+    #[cfg(unix)]
+    {
+        let null_fd = file_null.as_raw_fd();
+        dup2(null_fd, io::stdout().as_raw_fd())?;
+        if std::env::var("LIBAFL_FUZZBENCH_DEBUG").is_err() {
+            dup2(null_fd, io::stderr().as_raw_fd())?;
+        }
+    }
+    // reopen file to make sure we're at the end
+    log.replace(OpenOptions::new().append(true).create(true).open(logfile)?);
+
+    fuzzer.fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)?;
+
+    // Never reached
+    Ok(())
+}
diff --git a/fuzzers/ddfuzz/stub_rt.c b/fuzzers/ddfuzz/stub_rt.c
new file mode 100644
index 00000000..825d6780
--- /dev/null
+++ b/fuzzers/ddfuzz/stub_rt.c
@@ -0,0 +1,34 @@
+#include <stdint.h>
+
+__attribute__((weak)) void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,
+                                                               uint32_t *stop) {
+}
+
+__attribute__((weak)) void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
+}
+
+__attribute__((weak)) void __cmplog_rtn_hook(uint8_t *ptr1, uint8_t *ptr2) {
+}
+
+__attribute__((weak)) void __cmplog_rtn_gcc_stdstring_cstring(
+    uint8_t *stdstring, uint8_t *cstring) {
+}
+
+__attribute__((weak)) void __cmplog_rtn_gcc_stdstring_stdstring(
+    uint8_t *stdstring1, uint8_t *stdstring2) {
+}
+
+__attribute__((weak)) void __cmplog_rtn_llvm_stdstring_cstring(
+    uint8_t *stdstring, uint8_t *cstring) {
+}
+
+__attribute__((weak)) void __cmplog_rtn_llvm_stdstring_stdstring(
+    uint8_t *stdstring1, uint8_t *stdstring2) {
+}
+
+extern void libafl_main(void);
+
+int main(int argc, char **argv) {
+  libafl_main();
+  return 0;
+}
diff --git a/libafl_targets/src/coverage.rs b/libafl_targets/src/coverage.rs
index 1d7b88f0..e1cf70fc 100644
--- a/libafl_targets/src/coverage.rs
+++ b/libafl_targets/src/coverage.rs
@@ -295,3 +295,39 @@ mod swap {
         }
     }
 }
+
+/// Gets the edges map from the `DDG_MAP_PTR` raw pointer.
+/// Assumes a `len` of `DDG_MAP_SIZE`.
+///
+/// # Safety
+///
+/// This function will crash if `ddg_map_mut_ptr` is not a valid pointer.
+pub unsafe fn ddg_map_mut_slice<'a>() -> OwnedMutSlice<'a, u8> {
+    OwnedMutSlice::from_raw_parts_mut(ddg_map_mut_ptr(), DDG_MAP_SIZE)
+}
+
+/// Gets a new [`StdMapObserver`] from the current [`ddg_map_mut_slice`].
+///
+/// # Safety
+/// This will dereference [`ddg_map_mut_ptr`] and crash if it is not a valid address.
+pub unsafe fn std_ddg_map_observer<'a, S>(name: S) -> StdMapObserver<'a, u8, false>
+    where
+        S: Into<Cow<'static, str>>,
+{
+    StdMapObserver::from_mut_slice(name, ddg_map_mut_slice())
+}
+
+/// Gets the current edges map pt
+/// It will usually take `DDG_MAP`, but `DDG_MAP_PTR`,
+/// if built with the `pointer_maps` feature.
+#[must_use]
+pub fn ddg_map_mut_ptr() -> *mut u8 {
+    unsafe {
+        if cfg!(feature = "pointer_maps") {
+            assert!(!DDG_MAP_PTR.is_null());
+            DDG_MAP_PTR
+        } else {
+            DDG_MAP.as_mut_ptr()
+        }
+    }
+}
\ No newline at end of file
